秒杀对系统的要求
  秒杀场景：限时限量
  秒杀特征：
    并发访问量大
    读多写少
  秒杀环节：
    秒杀前：用户刷新商品详情页，通过cdn缓存静态资源或者或者浏览器缓存
    秒杀中：
      用户点击商品详情，查询库存
      然后库存减扣，
      生成订单
    秒杀后：
      流量已经很低，不在讨论
  注意的问题
    redis 用于库存查询，库存减扣，并且这两个操作必须是原子性操作：可以使用分布式锁以及lua脚本
    mysql 用于订单处理
    这样设计的目的
        减少额外的开销，redis已经做了“查和减”的操作
        避免出现超售，mysql 性能比较慢，

Redis 那些方法支持秒杀场景
  要求
    支持高并发（通过切片集群，将不同商品保存在不同实例上）
    查和减，需要原子性操作（通过redis原子性操作，以及分布式锁来支持）
  其他环节主要优化
    前端静态页面设置：走cdn和缓存
    请求拦截和流控：非法请求
    库存信息过期：避免缓存击穿
    数据库订单异常：增加重试功能

缓存雪崩
  大量的可以失效：1）随机过期，避免大面积失效 2）永不过期
缓存穿透
  redis 和 mysql 都不存在 大量的请求落到数据库 1）设置空值 2）布隆过滤器，将数据库存在的key提前加入
缓存击穿  数据过期那一时刻，大量的请求落到数据上 1）加锁更新访问
参考：https://www.jianshu.com/p/b57d0773ee96


按照惯例，我给你提个小问题，假设一个商品的库存量是 800，我们使用一个包含了 4 个实例的切片集群来服务秒杀请求。我们让每个实例各自维护库存量 200，然后，客户端的秒杀请求可以分发到不同的实例上进行处理，你觉得这是一个好方法吗？
    前提事数据能均匀打在切片上，如果不是均匀的话，就会造成数据倾斜，反而造成压力过大，严重造成商品残留的情况
    如果要查询剩余库存，需要查询多个切片
    秒杀系统核心要点：静态资源cdn 或者缓存，恶意请求拦截，验证减库存原子操作，消息队列处理订单
