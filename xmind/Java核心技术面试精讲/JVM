JVM
https://thinkwon.blog.csdn.net/article/details/104390752

1、jvm 主要组成
  1 运行数据
    1）堆
    2）栈
    3）程序计数器
    4）方法区
    5）本地方法区
  2、子系统
    1）类加载系统
    2）执行引擎
  3）本地接口

2、深拷贝和浅拷贝
  2.1 拷贝：是对于基本数据类型来说的，
    1）浅拷贝：他增加一个指针指向相同的区域，当以前的指针改变时候，数据不会改变，还是执行原来的地址
    2）深拷贝：复制一块数据，将新增的地址执行他
  2.2 复制：针对对象来说的
    1）浅复制：复制相同的地址，当数据改变，新增的数据，也会改变
    2）深拷贝：开辟新的空间，新的指针指向新开辟的地址空间
3、堆栈的区别
  1）存储对象不同，一个是对象或者数组，更加专注存储，一个存的是临时变量，操作数栈，放回值，专注程序的执行
  2）是否连续，栈在编译时期就已经确定
  3）程序是否可见

4、队列和栈区别
  1）操作名称不同，出栈入栈，弹入弹出
  1）他们两个是不同的数据结构，栈是先进先出，队列是先进后出
5、对象创建方式：单例构造
  1）new
  2）controll
  3）class.newInstans
  4) clone
  5) 序列化

6、对象创建的流程
  1）加载class资源
  2）分配内存 【分配方式：1、指针碰撞，空闲列表，并发问题解决：1、cas，2tlab】
  3）初始化资源
  4）执行init

7、对象实例化过程
  7.1 加载
    1）通过全额限定名获取二进制流文件
    2）将流文件加载到方法，生成对于的结构化数据
    3）生成class 对象，指向结构化数据
  7.2 验证
    1）字节码验证
    2）符号验证
    3）应用验证
  7.3 准备
    1）初始化内存，对于static final 基本数据类或者包装类，或者String 编译时期会替换
  7.4 链接
    1）替换引用
  7.4 初始化
    1）执行Cinit

8、对象访问的方式
  1、句柄 java 采用的这种方式，中间多方了一层，
  2、指针，访问速度比较快

9、java会存在内存溢出吗
  1、内存溢出短生命周期的对象，但是长期得不到释放，造成jvm 的资源得不到有效回收，造成资源溢出
  2、虽然jvm有自动垃圾回收机制，但是存在大量的不合理的引用，一样也会造成内存溢出

10、简述垃圾回收机制
  1、当对象不再被gc-root 之后，当资源不足时候，该对象就会而被回收

11、GC 是什么，为什么要GC
  1）GC 就是垃圾收集
  2）java对象不想C++需要手动释放资源，提高开发效率，而是通过垃圾收集，通过遍历GC-ROOT，遍历所能关联的对象，没有关联的对象将占的内存，将被释放

12、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
 1、原理
  1）初始标记
   1）通过遍历GC-ROOT，关联上能够关联的对象，没有关联上的对象，就要被回收
  2）并发标记
  3）重新标记
  4）并发清除
 2、能马上回收内存吗
  1、不能，需要等资源不足时候，才能吊起垃圾回收，通过GC-ROOT 遍历对象，没有关联上的，就会回收
3、 通知回收
  1）通过System.gc(),但是不能保证执行

13、java中有哪些引用
  1）强引用：发生GC，不会回收
  2）软应用：当内存不足时候，收集该区域
  3）弱应用：一发现是，就会回收
  4）虚引用：这是回收的一个状态，无法访问

判断对象能否被回收的方法
  1）引用计数器，无法解决，循环引用问题
  2）对象是否可达，java采用这种方式，java通过gc-root遍历能够关联上的对象，没有关联上的对象就回收
    1）能够最为gc-root对象的有，1、常量池，2、线程变量，3类变量

对象分配规则
  1）对象优先在eden分配
  2）大对象直接进入老年代
  3）对象存活一定年龄，也会进入老年代
  4）动态年龄判断，大于平均年龄，就如老年代
  5）空间分配担保

full-GC 触发的条件
  1）System.gc()
  2) 老年代不足
  3）方法资源不足
  4）通过minor 进入进入老年代大于老年代可用资源【老的资源，复制到老年代】
  5）空间担保失败，但是老年代也没有足够的资源

有哪些垃圾回收算法
  1）标记清除
  2）标记复制
  3）标记整理
  4）分代算法

垃圾收回收器
1） serial  parNew       parallel-scavenge（最大吐量）
                                          G1
2） cms（最先时延）       serial-old   parallel-old
一般年轻代使用复制算法，老年代使用标记整理算法，这个是根据他们各自不同的特点，新生代，存活对象少，采用复制算法，效率比较高
老年代，存活对象比较多，当空间充足，采用并发清除，（会产生空间碎片）当空间不足时，采用并发整理（不会产生空间碎片，但是比较耗费时间）
cms：介绍
  1）CMS 英文名为concurrent-mark-sweep，采用并发清除，会产生碎片，但老年代的资源不满足是，发生清理失败，进而听过serial-old，单线程工作，这种情况是很糟糕的
  2）工作流程
    1、初始标记：通过GC_ROOT关联上能够关联的对象：stop-word，GC-ROOT 不是很多，所以这个过程是很快的

    2）并发标记，这个过程是和用户线程一起执行的，会产生两个问题1、浮动垃圾，这种对系统的影响不大，下次GC清理一下，就行，还有一个问题是，对象消失，cms，通过一个类似快照算法，解决了

    3、重新标记，上一个阶段，在用户运行时运行，遗留了部分变化的对象，需要留在这个阶段，重关联上，这一个阶段也是stop-world

    4）并发清除
    通过牺牲吞吐量，获取低时延，

简述分代回收器如何工作
  1）java堆分为两个区域，老年代，和新生代，米认为1:2
  2）新生代采用标记复制，他划分为一个Service，2个to，占比为8:1:1
  但新生代回收时候，把存活的对象，复制其中一个to上，如果空间不足
  老年代将进行担保，失败，则直接老年代
  这时候，将to 和From 置换，每次收集慧，对象年龄甲乙，达到一定年龄
自动升级到老年代，当存活的对象的超过平均年龄，这回直接送往老年代，这是动态判断

老年代，可以通过参数控制行为，1、空间占用率，2、周期等

内存分配策略
  1）对象优先在年轻代分配
  2）大对象直接去老年代
  3）老年代空间担保失败，会分配在老年代
  4）通过参数配置，可以在tlab上分配

请描述一下jvm加载class文件的原理机制
  加载，更为三步
  1）通过全额限定名，加载一个二进制资源
  2）将这个资源存放早方法区，生成一个结构化数据
  3）为这个结构h数据生成一个class对象，
  这一期都是通过ClassLoader来完成，
  当代码运行，遇上new 的的时候，执行引擎默认帮我们执行以上步骤--这是隐式技术在
  当代码通过class.forName(),这种方式，执行引擎会显示的帮我执行以上步骤

  类加载是动态，当需要什么，才会去加载，节省内存

  什么是类加载器
  1）类加载系统，是jvm的一个系统，他还有另外一个子系统，垃圾收集系统
  类加载系统是用于加载系统所需执行资源
，有以下的里加载器
  1）BootClassLoader
  2）extensions Class Loader
  3）appClassLoader
  4）用户自定义的classLoader

双亲委派模型
  1）对于任意一个类，确定的为唯一性，除了原始资源外，还有ClassLoader确定，这便是，同一个资源，可以不同的CladdLoader加载，这样会造成一个问题，资源的冗余，通过双亲委派设计，当期ClassLoader查找资源时候，不直接去找，而是先请求他的父亲CladdLoader去加载，一直递归在BootCladdLoader，如果没有找到，然后后再根据相应的路径去查查找


JVM调优工具
  1）jps
  2）Jconsole：堆栈线程类进项监控
  3）jvisualVM：全能工具，快照，内存、线程死锁等

常用的JVM调优参数
  1）-Xms：堆初始化
  2）-Xmm：最大堆
  3）-XX:NewRatio:新生代与老生比值
  4) -XX:servivorRatio：新生代与eden与servivor 比值
  5) -XX:+UseParNewGC：使用parNew 和Serial-old助手
  6）-XX：UseConcMarkSweepGC：使用cms+serial-old
  7）-XX：+PrintGC
  8）-XX：PrintGCDetail
